"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const oss_client_1 = __importStar(require("@alicloud/oss-client")), $OSS = oss_client_1;
const openplatform20191219_1 = __importStar(require("@alicloud/openplatform20191219")), $OpenPlatform = openplatform20191219_1;
const $OSSUtil = __importStar(require("@alicloud/oss-util"));
const $FileForm = __importStar(require("@alicloud/tea-fileform"));
const number_1 = __importDefault(require("@darabonba/number"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const endpoint_util_1 = __importDefault(require("@alicloud/endpoint-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class DetectCardScreenshotRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.DetectCardScreenshotRequest = DetectCardScreenshotRequest;
class DetectCardScreenshotAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.DetectCardScreenshotAdvanceRequest = DetectCardScreenshotAdvanceRequest;
class DetectCardScreenshotResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: DetectCardScreenshotResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.DetectCardScreenshotResponseBody = DetectCardScreenshotResponseBody;
class DetectCardScreenshotResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DetectCardScreenshotResponseBody,
        };
    }
}
exports.DetectCardScreenshotResponse = DetectCardScreenshotResponse;
class GetAsyncJobResultRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            jobId: 'string',
        };
    }
}
exports.GetAsyncJobResultRequest = GetAsyncJobResultRequest;
class GetAsyncJobResultResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: GetAsyncJobResultResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.GetAsyncJobResultResponseBody = GetAsyncJobResultResponseBody;
class GetAsyncJobResultResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAsyncJobResultResponseBody,
        };
    }
}
exports.GetAsyncJobResultResponse = GetAsyncJobResultResponse;
class RecognizeAccountPageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeAccountPageRequest = RecognizeAccountPageRequest;
class RecognizeAccountPageAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeAccountPageAdvanceRequest = RecognizeAccountPageAdvanceRequest;
class RecognizeAccountPageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeAccountPageResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeAccountPageResponseBody = RecognizeAccountPageResponseBody;
class RecognizeAccountPageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeAccountPageResponseBody,
        };
    }
}
exports.RecognizeAccountPageResponse = RecognizeAccountPageResponse;
class RecognizeBankCardRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeBankCardRequest = RecognizeBankCardRequest;
class RecognizeBankCardAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeBankCardAdvanceRequest = RecognizeBankCardAdvanceRequest;
class RecognizeBankCardResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeBankCardResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeBankCardResponseBody = RecognizeBankCardResponseBody;
class RecognizeBankCardResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeBankCardResponseBody,
        };
    }
}
exports.RecognizeBankCardResponse = RecognizeBankCardResponse;
class RecognizeBusinessCardRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeBusinessCardRequest = RecognizeBusinessCardRequest;
class RecognizeBusinessCardAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeBusinessCardAdvanceRequest = RecognizeBusinessCardAdvanceRequest;
class RecognizeBusinessCardResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeBusinessCardResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeBusinessCardResponseBody = RecognizeBusinessCardResponseBody;
class RecognizeBusinessCardResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeBusinessCardResponseBody,
        };
    }
}
exports.RecognizeBusinessCardResponse = RecognizeBusinessCardResponse;
class RecognizeBusinessLicenseRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeBusinessLicenseRequest = RecognizeBusinessLicenseRequest;
class RecognizeBusinessLicenseAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeBusinessLicenseAdvanceRequest = RecognizeBusinessLicenseAdvanceRequest;
class RecognizeBusinessLicenseResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeBusinessLicenseResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeBusinessLicenseResponseBody = RecognizeBusinessLicenseResponseBody;
class RecognizeBusinessLicenseResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeBusinessLicenseResponseBody,
        };
    }
}
exports.RecognizeBusinessLicenseResponse = RecognizeBusinessLicenseResponse;
class RecognizeCharacterRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
            minHeight: 'MinHeight',
            outputProbability: 'OutputProbability',
        };
    }
    static types() {
        return {
            imageURL: 'string',
            minHeight: 'number',
            outputProbability: 'boolean',
        };
    }
}
exports.RecognizeCharacterRequest = RecognizeCharacterRequest;
class RecognizeCharacterAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
            minHeight: 'MinHeight',
            outputProbability: 'OutputProbability',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
            minHeight: 'number',
            outputProbability: 'boolean',
        };
    }
}
exports.RecognizeCharacterAdvanceRequest = RecognizeCharacterAdvanceRequest;
class RecognizeCharacterResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeCharacterResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeCharacterResponseBody = RecognizeCharacterResponseBody;
class RecognizeCharacterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeCharacterResponseBody,
        };
    }
}
exports.RecognizeCharacterResponse = RecognizeCharacterResponse;
class RecognizeChinapassportRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeChinapassportRequest = RecognizeChinapassportRequest;
class RecognizeChinapassportAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeChinapassportAdvanceRequest = RecognizeChinapassportAdvanceRequest;
class RecognizeChinapassportResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeChinapassportResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeChinapassportResponseBody = RecognizeChinapassportResponseBody;
class RecognizeChinapassportResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeChinapassportResponseBody,
        };
    }
}
exports.RecognizeChinapassportResponse = RecognizeChinapassportResponse;
class RecognizeDriverLicenseRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
            side: 'Side',
        };
    }
    static types() {
        return {
            imageURL: 'string',
            side: 'string',
        };
    }
}
exports.RecognizeDriverLicenseRequest = RecognizeDriverLicenseRequest;
class RecognizeDriverLicenseAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
            side: 'Side',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
            side: 'string',
        };
    }
}
exports.RecognizeDriverLicenseAdvanceRequest = RecognizeDriverLicenseAdvanceRequest;
class RecognizeDriverLicenseResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeDriverLicenseResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeDriverLicenseResponseBody = RecognizeDriverLicenseResponseBody;
class RecognizeDriverLicenseResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeDriverLicenseResponseBody,
        };
    }
}
exports.RecognizeDriverLicenseResponse = RecognizeDriverLicenseResponse;
class RecognizeDrivingLicenseRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
            side: 'Side',
        };
    }
    static types() {
        return {
            imageURL: 'string',
            side: 'string',
        };
    }
}
exports.RecognizeDrivingLicenseRequest = RecognizeDrivingLicenseRequest;
class RecognizeDrivingLicenseAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
            side: 'Side',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
            side: 'string',
        };
    }
}
exports.RecognizeDrivingLicenseAdvanceRequest = RecognizeDrivingLicenseAdvanceRequest;
class RecognizeDrivingLicenseResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeDrivingLicenseResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeDrivingLicenseResponseBody = RecognizeDrivingLicenseResponseBody;
class RecognizeDrivingLicenseResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeDrivingLicenseResponseBody,
        };
    }
}
exports.RecognizeDrivingLicenseResponse = RecognizeDrivingLicenseResponse;
class RecognizeIdentityCardRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
            side: 'Side',
        };
    }
    static types() {
        return {
            imageURL: 'string',
            side: 'string',
        };
    }
}
exports.RecognizeIdentityCardRequest = RecognizeIdentityCardRequest;
class RecognizeIdentityCardAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
            side: 'Side',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
            side: 'string',
        };
    }
}
exports.RecognizeIdentityCardAdvanceRequest = RecognizeIdentityCardAdvanceRequest;
class RecognizeIdentityCardResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeIdentityCardResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeIdentityCardResponseBody = RecognizeIdentityCardResponseBody;
class RecognizeIdentityCardResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeIdentityCardResponseBody,
        };
    }
}
exports.RecognizeIdentityCardResponse = RecognizeIdentityCardResponse;
class RecognizeLicensePlateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeLicensePlateRequest = RecognizeLicensePlateRequest;
class RecognizeLicensePlateAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeLicensePlateAdvanceRequest = RecognizeLicensePlateAdvanceRequest;
class RecognizeLicensePlateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeLicensePlateResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeLicensePlateResponseBody = RecognizeLicensePlateResponseBody;
class RecognizeLicensePlateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeLicensePlateResponseBody,
        };
    }
}
exports.RecognizeLicensePlateResponse = RecognizeLicensePlateResponse;
class RecognizePassportMRZRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizePassportMRZRequest = RecognizePassportMRZRequest;
class RecognizePassportMRZAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizePassportMRZAdvanceRequest = RecognizePassportMRZAdvanceRequest;
class RecognizePassportMRZResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizePassportMRZResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizePassportMRZResponseBody = RecognizePassportMRZResponseBody;
class RecognizePassportMRZResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizePassportMRZResponseBody,
        };
    }
}
exports.RecognizePassportMRZResponse = RecognizePassportMRZResponse;
class RecognizePdfRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileURL: 'FileURL',
        };
    }
    static types() {
        return {
            fileURL: 'string',
        };
    }
}
exports.RecognizePdfRequest = RecognizePdfRequest;
class RecognizePdfAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileURLObject: 'FileURL',
        };
    }
    static types() {
        return {
            fileURLObject: 'Readable',
        };
    }
}
exports.RecognizePdfAdvanceRequest = RecognizePdfAdvanceRequest;
class RecognizePdfResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizePdfResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizePdfResponseBody = RecognizePdfResponseBody;
class RecognizePdfResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizePdfResponseBody,
        };
    }
}
exports.RecognizePdfResponse = RecognizePdfResponse;
class RecognizePoiNameRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizePoiNameRequest = RecognizePoiNameRequest;
class RecognizePoiNameAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizePoiNameAdvanceRequest = RecognizePoiNameAdvanceRequest;
class RecognizePoiNameResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizePoiNameResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizePoiNameResponseBody = RecognizePoiNameResponseBody;
class RecognizePoiNameResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizePoiNameResponseBody,
        };
    }
}
exports.RecognizePoiNameResponse = RecognizePoiNameResponse;
class RecognizeQrCodeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tasks: 'Tasks',
        };
    }
    static types() {
        return {
            tasks: { 'type': 'array', 'itemType': RecognizeQrCodeRequestTasks },
        };
    }
}
exports.RecognizeQrCodeRequest = RecognizeQrCodeRequest;
class RecognizeQrCodeAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tasks: 'Tasks',
        };
    }
    static types() {
        return {
            tasks: { 'type': 'array', 'itemType': RecognizeQrCodeAdvanceRequestTasks },
        };
    }
}
exports.RecognizeQrCodeAdvanceRequest = RecognizeQrCodeAdvanceRequest;
class RecognizeQrCodeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeQrCodeResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeQrCodeResponseBody = RecognizeQrCodeResponseBody;
class RecognizeQrCodeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeQrCodeResponseBody,
        };
    }
}
exports.RecognizeQrCodeResponse = RecognizeQrCodeResponse;
class RecognizeQuotaInvoiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeQuotaInvoiceRequest = RecognizeQuotaInvoiceRequest;
class RecognizeQuotaInvoiceAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeQuotaInvoiceAdvanceRequest = RecognizeQuotaInvoiceAdvanceRequest;
class RecognizeQuotaInvoiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeQuotaInvoiceResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeQuotaInvoiceResponseBody = RecognizeQuotaInvoiceResponseBody;
class RecognizeQuotaInvoiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeQuotaInvoiceResponseBody,
        };
    }
}
exports.RecognizeQuotaInvoiceResponse = RecognizeQuotaInvoiceResponse;
class RecognizeStampRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeStampRequest = RecognizeStampRequest;
class RecognizeStampAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeStampAdvanceRequest = RecognizeStampAdvanceRequest;
class RecognizeStampResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeStampResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeStampResponseBody = RecognizeStampResponseBody;
class RecognizeStampResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeStampResponseBody,
        };
    }
}
exports.RecognizeStampResponse = RecognizeStampResponse;
class RecognizeTableRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            assureDirection: 'AssureDirection',
            hasLine: 'HasLine',
            imageURL: 'ImageURL',
            outputFormat: 'OutputFormat',
            skipDetection: 'SkipDetection',
            useFinanceModel: 'UseFinanceModel',
        };
    }
    static types() {
        return {
            assureDirection: 'boolean',
            hasLine: 'boolean',
            imageURL: 'string',
            outputFormat: 'string',
            skipDetection: 'boolean',
            useFinanceModel: 'boolean',
        };
    }
}
exports.RecognizeTableRequest = RecognizeTableRequest;
class RecognizeTableAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            assureDirection: 'AssureDirection',
            hasLine: 'HasLine',
            imageURLObject: 'ImageURL',
            outputFormat: 'OutputFormat',
            skipDetection: 'SkipDetection',
            useFinanceModel: 'UseFinanceModel',
        };
    }
    static types() {
        return {
            assureDirection: 'boolean',
            hasLine: 'boolean',
            imageURLObject: 'Readable',
            outputFormat: 'string',
            skipDetection: 'boolean',
            useFinanceModel: 'boolean',
        };
    }
}
exports.RecognizeTableAdvanceRequest = RecognizeTableAdvanceRequest;
class RecognizeTableResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeTableResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeTableResponseBody = RecognizeTableResponseBody;
class RecognizeTableResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeTableResponseBody,
        };
    }
}
exports.RecognizeTableResponse = RecognizeTableResponse;
class RecognizeTakeoutOrderRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeTakeoutOrderRequest = RecognizeTakeoutOrderRequest;
class RecognizeTakeoutOrderAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeTakeoutOrderAdvanceRequest = RecognizeTakeoutOrderAdvanceRequest;
class RecognizeTakeoutOrderResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeTakeoutOrderResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeTakeoutOrderResponseBody = RecognizeTakeoutOrderResponseBody;
class RecognizeTakeoutOrderResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeTakeoutOrderResponseBody,
        };
    }
}
exports.RecognizeTakeoutOrderResponse = RecognizeTakeoutOrderResponse;
class RecognizeTaxiInvoiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeTaxiInvoiceRequest = RecognizeTaxiInvoiceRequest;
class RecognizeTaxiInvoiceAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeTaxiInvoiceAdvanceRequest = RecognizeTaxiInvoiceAdvanceRequest;
class RecognizeTaxiInvoiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeTaxiInvoiceResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeTaxiInvoiceResponseBody = RecognizeTaxiInvoiceResponseBody;
class RecognizeTaxiInvoiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeTaxiInvoiceResponseBody,
        };
    }
}
exports.RecognizeTaxiInvoiceResponse = RecognizeTaxiInvoiceResponse;
class RecognizeTicketInvoiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeTicketInvoiceRequest = RecognizeTicketInvoiceRequest;
class RecognizeTicketInvoiceAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeTicketInvoiceAdvanceRequest = RecognizeTicketInvoiceAdvanceRequest;
class RecognizeTicketInvoiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeTicketInvoiceResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeTicketInvoiceResponseBody = RecognizeTicketInvoiceResponseBody;
class RecognizeTicketInvoiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeTicketInvoiceResponseBody,
        };
    }
}
exports.RecognizeTicketInvoiceResponse = RecognizeTicketInvoiceResponse;
class RecognizeTrainTicketRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeTrainTicketRequest = RecognizeTrainTicketRequest;
class RecognizeTrainTicketAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeTrainTicketAdvanceRequest = RecognizeTrainTicketAdvanceRequest;
class RecognizeTrainTicketResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeTrainTicketResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeTrainTicketResponseBody = RecognizeTrainTicketResponseBody;
class RecognizeTrainTicketResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeTrainTicketResponseBody,
        };
    }
}
exports.RecognizeTrainTicketResponse = RecognizeTrainTicketResponse;
class RecognizeVATInvoiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileType: 'FileType',
            fileURL: 'FileURL',
        };
    }
    static types() {
        return {
            fileType: 'string',
            fileURL: 'string',
        };
    }
}
exports.RecognizeVATInvoiceRequest = RecognizeVATInvoiceRequest;
class RecognizeVATInvoiceAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileType: 'FileType',
            fileURLObject: 'FileURL',
        };
    }
    static types() {
        return {
            fileType: 'string',
            fileURLObject: 'Readable',
        };
    }
}
exports.RecognizeVATInvoiceAdvanceRequest = RecognizeVATInvoiceAdvanceRequest;
class RecognizeVATInvoiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeVATInvoiceResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeVATInvoiceResponseBody = RecognizeVATInvoiceResponseBody;
class RecognizeVATInvoiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeVATInvoiceResponseBody,
        };
    }
}
exports.RecognizeVATInvoiceResponse = RecognizeVATInvoiceResponse;
class RecognizeVINCodeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeVINCodeRequest = RecognizeVINCodeRequest;
class RecognizeVINCodeAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeVINCodeAdvanceRequest = RecognizeVINCodeAdvanceRequest;
class RecognizeVINCodeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeVINCodeResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeVINCodeResponseBody = RecognizeVINCodeResponseBody;
class RecognizeVINCodeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeVINCodeResponseBody,
        };
    }
}
exports.RecognizeVINCodeResponse = RecognizeVINCodeResponse;
class RecognizeVerificationcodeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeVerificationcodeRequest = RecognizeVerificationcodeRequest;
class RecognizeVerificationcodeAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeVerificationcodeAdvanceRequest = RecognizeVerificationcodeAdvanceRequest;
class RecognizeVerificationcodeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeVerificationcodeResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeVerificationcodeResponseBody = RecognizeVerificationcodeResponseBody;
class RecognizeVerificationcodeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeVerificationcodeResponseBody,
        };
    }
}
exports.RecognizeVerificationcodeResponse = RecognizeVerificationcodeResponse;
class RecognizeVideoCharacterRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            videoURL: 'VideoURL',
        };
    }
    static types() {
        return {
            videoURL: 'string',
        };
    }
}
exports.RecognizeVideoCharacterRequest = RecognizeVideoCharacterRequest;
class RecognizeVideoCharacterAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            videoURLObject: 'VideoURL',
        };
    }
    static types() {
        return {
            videoURLObject: 'Readable',
        };
    }
}
exports.RecognizeVideoCharacterAdvanceRequest = RecognizeVideoCharacterAdvanceRequest;
class RecognizeVideoCharacterResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeVideoCharacterResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
}
exports.RecognizeVideoCharacterResponseBody = RecognizeVideoCharacterResponseBody;
class RecognizeVideoCharacterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeVideoCharacterResponseBody,
        };
    }
}
exports.RecognizeVideoCharacterResponse = RecognizeVideoCharacterResponse;
class TrimDocumentRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileType: 'FileType',
            fileURL: 'FileURL',
            outputType: 'OutputType',
        };
    }
    static types() {
        return {
            fileType: 'string',
            fileURL: 'string',
            outputType: 'string',
        };
    }
}
exports.TrimDocumentRequest = TrimDocumentRequest;
class TrimDocumentAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileType: 'FileType',
            fileURLObject: 'FileURL',
            outputType: 'OutputType',
        };
    }
    static types() {
        return {
            fileType: 'string',
            fileURLObject: 'Readable',
            outputType: 'string',
        };
    }
}
exports.TrimDocumentAdvanceRequest = TrimDocumentAdvanceRequest;
class TrimDocumentResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: TrimDocumentResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
}
exports.TrimDocumentResponseBody = TrimDocumentResponseBody;
class TrimDocumentResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TrimDocumentResponseBody,
        };
    }
}
exports.TrimDocumentResponse = TrimDocumentResponse;
class DetectCardScreenshotResponseBodyDataSpoofResultResultMap extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            screenScore: 'ScreenScore',
            screenThreshold: 'ScreenThreshold',
        };
    }
    static types() {
        return {
            screenScore: 'number',
            screenThreshold: 'number',
        };
    }
}
exports.DetectCardScreenshotResponseBodyDataSpoofResultResultMap = DetectCardScreenshotResponseBodyDataSpoofResultResultMap;
class DetectCardScreenshotResponseBodyDataSpoofResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            isSpoof: 'IsSpoof',
            resultMap: 'ResultMap',
        };
    }
    static types() {
        return {
            isSpoof: 'boolean',
            resultMap: DetectCardScreenshotResponseBodyDataSpoofResultResultMap,
        };
    }
}
exports.DetectCardScreenshotResponseBodyDataSpoofResult = DetectCardScreenshotResponseBodyDataSpoofResult;
class DetectCardScreenshotResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            isBlur: 'IsBlur',
            isCard: 'IsCard',
            spoofResult: 'SpoofResult',
        };
    }
    static types() {
        return {
            isBlur: 'boolean',
            isCard: 'boolean',
            spoofResult: DetectCardScreenshotResponseBodyDataSpoofResult,
        };
    }
}
exports.DetectCardScreenshotResponseBodyData = DetectCardScreenshotResponseBodyData;
class GetAsyncJobResultResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'ErrorCode',
            errorMessage: 'ErrorMessage',
            jobId: 'JobId',
            result: 'Result',
            status: 'Status',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMessage: 'string',
            jobId: 'string',
            result: 'string',
            status: 'string',
        };
    }
}
exports.GetAsyncJobResultResponseBodyData = GetAsyncJobResultResponseBodyData;
class RecognizeAccountPageResponseBodyDataInvalidStampAreas extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeAccountPageResponseBodyDataInvalidStampAreas = RecognizeAccountPageResponseBodyDataInvalidStampAreas;
class RecognizeAccountPageResponseBodyDataOtherStampAreas extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeAccountPageResponseBodyDataOtherStampAreas = RecognizeAccountPageResponseBodyDataOtherStampAreas;
class RecognizeAccountPageResponseBodyDataRegisterStampAreas extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeAccountPageResponseBodyDataRegisterStampAreas = RecognizeAccountPageResponseBodyDataRegisterStampAreas;
class RecognizeAccountPageResponseBodyDataTitleArea extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeAccountPageResponseBodyDataTitleArea = RecognizeAccountPageResponseBodyDataTitleArea;
class RecognizeAccountPageResponseBodyDataUndertakeStampAreas extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeAccountPageResponseBodyDataUndertakeStampAreas = RecognizeAccountPageResponseBodyDataUndertakeStampAreas;
class RecognizeAccountPageResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            angle: 'Angle',
            birthDate: 'BirthDate',
            birthPlace: 'BirthPlace',
            gender: 'Gender',
            IDNumber: 'IDNumber',
            invalidStampAreas: 'InvalidStampAreas',
            name: 'Name',
            nationality: 'Nationality',
            nativePlace: 'NativePlace',
            otherStampAreas: 'OtherStampAreas',
            registerStampAreas: 'RegisterStampAreas',
            relation: 'Relation',
            titleArea: 'TitleArea',
            undertakeStampAreas: 'UndertakeStampAreas',
        };
    }
    static types() {
        return {
            angle: 'number',
            birthDate: 'string',
            birthPlace: 'string',
            gender: 'string',
            IDNumber: 'string',
            invalidStampAreas: { 'type': 'array', 'itemType': RecognizeAccountPageResponseBodyDataInvalidStampAreas },
            name: 'string',
            nationality: 'string',
            nativePlace: 'string',
            otherStampAreas: { 'type': 'array', 'itemType': RecognizeAccountPageResponseBodyDataOtherStampAreas },
            registerStampAreas: { 'type': 'array', 'itemType': RecognizeAccountPageResponseBodyDataRegisterStampAreas },
            relation: 'string',
            titleArea: RecognizeAccountPageResponseBodyDataTitleArea,
            undertakeStampAreas: { 'type': 'array', 'itemType': RecognizeAccountPageResponseBodyDataUndertakeStampAreas },
        };
    }
}
exports.RecognizeAccountPageResponseBodyData = RecognizeAccountPageResponseBodyData;
class RecognizeBankCardResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bankName: 'BankName',
            cardNumber: 'CardNumber',
            validDate: 'ValidDate',
        };
    }
    static types() {
        return {
            bankName: 'string',
            cardNumber: 'string',
            validDate: 'string',
        };
    }
}
exports.RecognizeBankCardResponseBodyData = RecognizeBankCardResponseBodyData;
class RecognizeBusinessCardResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addresses: 'Addresses',
            cellPhoneNumbers: 'CellPhoneNumbers',
            companies: 'Companies',
            departments: 'Departments',
            emails: 'Emails',
            name: 'Name',
            officePhoneNumbers: 'OfficePhoneNumbers',
            titles: 'Titles',
        };
    }
    static types() {
        return {
            addresses: { 'type': 'array', 'itemType': 'string' },
            cellPhoneNumbers: { 'type': 'array', 'itemType': 'string' },
            companies: { 'type': 'array', 'itemType': 'string' },
            departments: { 'type': 'array', 'itemType': 'string' },
            emails: { 'type': 'array', 'itemType': 'string' },
            name: 'string',
            officePhoneNumbers: { 'type': 'array', 'itemType': 'string' },
            titles: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.RecognizeBusinessCardResponseBodyData = RecognizeBusinessCardResponseBodyData;
class RecognizeBusinessLicenseResponseBodyDataEmblem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeBusinessLicenseResponseBodyDataEmblem = RecognizeBusinessLicenseResponseBodyDataEmblem;
class RecognizeBusinessLicenseResponseBodyDataQRCode extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeBusinessLicenseResponseBodyDataQRCode = RecognizeBusinessLicenseResponseBodyDataQRCode;
class RecognizeBusinessLicenseResponseBodyDataStamp extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeBusinessLicenseResponseBodyDataStamp = RecognizeBusinessLicenseResponseBodyDataStamp;
class RecognizeBusinessLicenseResponseBodyDataTitle extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeBusinessLicenseResponseBodyDataTitle = RecognizeBusinessLicenseResponseBodyDataTitle;
class RecognizeBusinessLicenseResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'Address',
            angle: 'Angle',
            business: 'Business',
            capital: 'Capital',
            emblem: 'Emblem',
            establishDate: 'EstablishDate',
            legalPerson: 'LegalPerson',
            name: 'Name',
            QRCode: 'QRCode',
            registerNumber: 'RegisterNumber',
            stamp: 'Stamp',
            title: 'Title',
            type: 'Type',
            validPeriod: 'ValidPeriod',
        };
    }
    static types() {
        return {
            address: 'string',
            angle: 'number',
            business: 'string',
            capital: 'string',
            emblem: RecognizeBusinessLicenseResponseBodyDataEmblem,
            establishDate: 'string',
            legalPerson: 'string',
            name: 'string',
            QRCode: RecognizeBusinessLicenseResponseBodyDataQRCode,
            registerNumber: 'string',
            stamp: RecognizeBusinessLicenseResponseBodyDataStamp,
            title: RecognizeBusinessLicenseResponseBodyDataTitle,
            type: 'string',
            validPeriod: 'string',
        };
    }
}
exports.RecognizeBusinessLicenseResponseBodyData = RecognizeBusinessLicenseResponseBodyData;
class RecognizeCharacterResponseBodyDataResultsTextRectangles extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            angle: 'Angle',
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            angle: 'number',
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeCharacterResponseBodyDataResultsTextRectangles = RecognizeCharacterResponseBodyDataResultsTextRectangles;
class RecognizeCharacterResponseBodyDataResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            probability: 'Probability',
            text: 'Text',
            textRectangles: 'TextRectangles',
        };
    }
    static types() {
        return {
            probability: 'number',
            text: 'string',
            textRectangles: RecognizeCharacterResponseBodyDataResultsTextRectangles,
        };
    }
}
exports.RecognizeCharacterResponseBodyDataResults = RecognizeCharacterResponseBodyDataResults;
class RecognizeCharacterResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            results: 'Results',
        };
    }
    static types() {
        return {
            results: { 'type': 'array', 'itemType': RecognizeCharacterResponseBodyDataResults },
        };
    }
}
exports.RecognizeCharacterResponseBodyData = RecognizeCharacterResponseBodyData;
class RecognizeChinapassportResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authority: 'Authority',
            birthDate: 'BirthDate',
            birthDay: 'BirthDay',
            birthPlace: 'BirthPlace',
            birthPlaceRaw: 'BirthPlaceRaw',
            country: 'Country',
            expiryDate: 'ExpiryDate',
            expiryDay: 'ExpiryDay',
            issueDate: 'IssueDate',
            issuePlace: 'IssuePlace',
            issuePlaceRaw: 'IssuePlaceRaw',
            lineOne: 'LineOne',
            lineZero: 'LineZero',
            name: 'Name',
            nameChinese: 'NameChinese',
            nameChineseRaw: 'NameChineseRaw',
            passportNo: 'PassportNo',
            personId: 'PersonId',
            sex: 'Sex',
            sourceCountry: 'SourceCountry',
            success: 'Success',
            type: 'Type',
        };
    }
    static types() {
        return {
            authority: 'string',
            birthDate: 'string',
            birthDay: 'string',
            birthPlace: 'string',
            birthPlaceRaw: 'string',
            country: 'string',
            expiryDate: 'string',
            expiryDay: 'string',
            issueDate: 'string',
            issuePlace: 'string',
            issuePlaceRaw: 'string',
            lineOne: 'string',
            lineZero: 'string',
            name: 'string',
            nameChinese: 'string',
            nameChineseRaw: 'string',
            passportNo: 'string',
            personId: 'string',
            sex: 'string',
            sourceCountry: 'string',
            success: 'boolean',
            type: 'string',
        };
    }
}
exports.RecognizeChinapassportResponseBodyData = RecognizeChinapassportResponseBodyData;
class RecognizeDriverLicenseResponseBodyDataBackResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            archiveNumber: 'ArchiveNumber',
            cardNumber: 'CardNumber',
            name: 'Name',
            record: 'Record',
        };
    }
    static types() {
        return {
            archiveNumber: 'string',
            cardNumber: 'string',
            name: 'string',
            record: 'string',
        };
    }
}
exports.RecognizeDriverLicenseResponseBodyDataBackResult = RecognizeDriverLicenseResponseBodyDataBackResult;
class RecognizeDriverLicenseResponseBodyDataFaceResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'Address',
            endDate: 'EndDate',
            gender: 'Gender',
            issueDate: 'IssueDate',
            issueUnit: 'IssueUnit',
            licenseNumber: 'LicenseNumber',
            name: 'Name',
            startDate: 'StartDate',
            vehicleType: 'VehicleType',
        };
    }
    static types() {
        return {
            address: 'string',
            endDate: 'string',
            gender: 'string',
            issueDate: 'string',
            issueUnit: 'string',
            licenseNumber: 'string',
            name: 'string',
            startDate: 'string',
            vehicleType: 'string',
        };
    }
}
exports.RecognizeDriverLicenseResponseBodyDataFaceResult = RecognizeDriverLicenseResponseBodyDataFaceResult;
class RecognizeDriverLicenseResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backResult: 'BackResult',
            faceResult: 'FaceResult',
        };
    }
    static types() {
        return {
            backResult: RecognizeDriverLicenseResponseBodyDataBackResult,
            faceResult: RecognizeDriverLicenseResponseBodyDataFaceResult,
        };
    }
}
exports.RecognizeDriverLicenseResponseBodyData = RecognizeDriverLicenseResponseBodyData;
class RecognizeDrivingLicenseResponseBodyDataBackResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            approvedLoad: 'ApprovedLoad',
            approvedPassengerCapacity: 'ApprovedPassengerCapacity',
            energyType: 'EnergyType',
            fileNumber: 'FileNumber',
            grossMass: 'GrossMass',
            inspectionRecord: 'InspectionRecord',
            overallDimension: 'OverallDimension',
            plateNumber: 'PlateNumber',
            tractionMass: 'TractionMass',
            unladenMass: 'UnladenMass',
        };
    }
    static types() {
        return {
            approvedLoad: 'string',
            approvedPassengerCapacity: 'string',
            energyType: 'string',
            fileNumber: 'string',
            grossMass: 'string',
            inspectionRecord: 'string',
            overallDimension: 'string',
            plateNumber: 'string',
            tractionMass: 'string',
            unladenMass: 'string',
        };
    }
}
exports.RecognizeDrivingLicenseResponseBodyDataBackResult = RecognizeDrivingLicenseResponseBodyDataBackResult;
class RecognizeDrivingLicenseResponseBodyDataFaceResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'Address',
            engineNumber: 'EngineNumber',
            issueDate: 'IssueDate',
            model: 'Model',
            owner: 'Owner',
            plateNumber: 'PlateNumber',
            registerDate: 'RegisterDate',
            useCharacter: 'UseCharacter',
            vehicleType: 'VehicleType',
            vin: 'Vin',
        };
    }
    static types() {
        return {
            address: 'string',
            engineNumber: 'string',
            issueDate: 'string',
            model: 'string',
            owner: 'string',
            plateNumber: 'string',
            registerDate: 'string',
            useCharacter: 'string',
            vehicleType: 'string',
            vin: 'string',
        };
    }
}
exports.RecognizeDrivingLicenseResponseBodyDataFaceResult = RecognizeDrivingLicenseResponseBodyDataFaceResult;
class RecognizeDrivingLicenseResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backResult: 'BackResult',
            faceResult: 'FaceResult',
        };
    }
    static types() {
        return {
            backResult: RecognizeDrivingLicenseResponseBodyDataBackResult,
            faceResult: RecognizeDrivingLicenseResponseBodyDataFaceResult,
        };
    }
}
exports.RecognizeDrivingLicenseResponseBodyData = RecognizeDrivingLicenseResponseBodyData;
class RecognizeIdentityCardResponseBodyDataBackResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endDate: 'EndDate',
            issue: 'Issue',
            startDate: 'StartDate',
        };
    }
    static types() {
        return {
            endDate: 'string',
            issue: 'string',
            startDate: 'string',
        };
    }
}
exports.RecognizeIdentityCardResponseBodyDataBackResult = RecognizeIdentityCardResponseBodyDataBackResult;
class RecognizeIdentityCardResponseBodyDataFrontResultCardAreas extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizeIdentityCardResponseBodyDataFrontResultCardAreas = RecognizeIdentityCardResponseBodyDataFrontResultCardAreas;
class RecognizeIdentityCardResponseBodyDataFrontResultFaceRectVertices extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizeIdentityCardResponseBodyDataFrontResultFaceRectVertices = RecognizeIdentityCardResponseBodyDataFrontResultFaceRectVertices;
class RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangleCenter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangleCenter = RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangleCenter;
class RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangleSize extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            width: 'Width',
        };
    }
    static types() {
        return {
            height: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangleSize = RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangleSize;
class RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangle extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            angle: 'Angle',
            center: 'Center',
            size: 'Size',
        };
    }
    static types() {
        return {
            angle: 'number',
            center: RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangleCenter,
            size: RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangleSize,
        };
    }
}
exports.RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangle = RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangle;
class RecognizeIdentityCardResponseBodyDataFrontResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'Address',
            birthDate: 'BirthDate',
            cardAreas: 'CardAreas',
            faceRectVertices: 'FaceRectVertices',
            faceRectangle: 'FaceRectangle',
            gender: 'Gender',
            IDNumber: 'IDNumber',
            name: 'Name',
            nationality: 'Nationality',
        };
    }
    static types() {
        return {
            address: 'string',
            birthDate: 'string',
            cardAreas: { 'type': 'array', 'itemType': RecognizeIdentityCardResponseBodyDataFrontResultCardAreas },
            faceRectVertices: { 'type': 'array', 'itemType': RecognizeIdentityCardResponseBodyDataFrontResultFaceRectVertices },
            faceRectangle: RecognizeIdentityCardResponseBodyDataFrontResultFaceRectangle,
            gender: 'string',
            IDNumber: 'string',
            name: 'string',
            nationality: 'string',
        };
    }
}
exports.RecognizeIdentityCardResponseBodyDataFrontResult = RecognizeIdentityCardResponseBodyDataFrontResult;
class RecognizeIdentityCardResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backResult: 'BackResult',
            frontResult: 'FrontResult',
        };
    }
    static types() {
        return {
            backResult: RecognizeIdentityCardResponseBodyDataBackResult,
            frontResult: RecognizeIdentityCardResponseBodyDataFrontResult,
        };
    }
}
exports.RecognizeIdentityCardResponseBodyData = RecognizeIdentityCardResponseBodyData;
class RecognizeLicensePlateResponseBodyDataPlatesPositions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizeLicensePlateResponseBodyDataPlatesPositions = RecognizeLicensePlateResponseBodyDataPlatesPositions;
class RecognizeLicensePlateResponseBodyDataPlatesRoi extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            h: 'H',
            w: 'W',
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            h: 'number',
            w: 'number',
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizeLicensePlateResponseBodyDataPlatesRoi = RecognizeLicensePlateResponseBodyDataPlatesRoi;
class RecognizeLicensePlateResponseBodyDataPlates extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            confidence: 'Confidence',
            plateNumber: 'PlateNumber',
            plateType: 'PlateType',
            plateTypeConfidence: 'PlateTypeConfidence',
            positions: 'Positions',
            roi: 'Roi',
        };
    }
    static types() {
        return {
            confidence: 'number',
            plateNumber: 'string',
            plateType: 'string',
            plateTypeConfidence: 'number',
            positions: { 'type': 'array', 'itemType': RecognizeLicensePlateResponseBodyDataPlatesPositions },
            roi: RecognizeLicensePlateResponseBodyDataPlatesRoi,
        };
    }
}
exports.RecognizeLicensePlateResponseBodyDataPlates = RecognizeLicensePlateResponseBodyDataPlates;
class RecognizeLicensePlateResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            plates: 'Plates',
        };
    }
    static types() {
        return {
            plates: { 'type': 'array', 'itemType': RecognizeLicensePlateResponseBodyDataPlates },
        };
    }
}
exports.RecognizeLicensePlateResponseBodyData = RecognizeLicensePlateResponseBodyData;
class RecognizePassportMRZResponseBodyDataRegions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bandBoxes: 'BandBoxes',
            content: 'Content',
            detectionScore: 'DetectionScore',
            name: 'Name',
            recognitionScore: 'RecognitionScore',
        };
    }
    static types() {
        return {
            bandBoxes: { 'type': 'array', 'itemType': 'number' },
            content: 'string',
            detectionScore: 'number',
            name: 'string',
            recognitionScore: 'number',
        };
    }
}
exports.RecognizePassportMRZResponseBodyDataRegions = RecognizePassportMRZResponseBodyDataRegions;
class RecognizePassportMRZResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            regions: 'Regions',
        };
    }
    static types() {
        return {
            regions: { 'type': 'array', 'itemType': RecognizePassportMRZResponseBodyDataRegions },
        };
    }
}
exports.RecognizePassportMRZResponseBodyData = RecognizePassportMRZResponseBodyData;
class RecognizePdfResponseBodyDataWordsInfoPositions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizePdfResponseBodyDataWordsInfoPositions = RecognizePdfResponseBodyDataWordsInfoPositions;
class RecognizePdfResponseBodyDataWordsInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            angle: 'Angle',
            height: 'Height',
            positions: 'Positions',
            width: 'Width',
            word: 'Word',
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            angle: 'number',
            height: 'number',
            positions: { 'type': 'array', 'itemType': RecognizePdfResponseBodyDataWordsInfoPositions },
            width: 'number',
            word: 'string',
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizePdfResponseBodyDataWordsInfo = RecognizePdfResponseBodyDataWordsInfo;
class RecognizePdfResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            angle: 'Angle',
            height: 'Height',
            orgHeight: 'OrgHeight',
            orgWidth: 'OrgWidth',
            pageIndex: 'PageIndex',
            width: 'Width',
            wordsInfo: 'WordsInfo',
        };
    }
    static types() {
        return {
            angle: 'number',
            height: 'number',
            orgHeight: 'number',
            orgWidth: 'number',
            pageIndex: 'number',
            width: 'number',
            wordsInfo: { 'type': 'array', 'itemType': RecognizePdfResponseBodyDataWordsInfo },
        };
    }
}
exports.RecognizePdfResponseBodyData = RecognizePdfResponseBodyData;
class RecognizePoiNameResponseBodyDataSignboardsTexts extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            label: 'Label',
            points: 'Points',
            score: 'Score',
            tag: 'Tag',
            type: 'Type',
        };
    }
    static types() {
        return {
            label: 'string',
            points: { 'type': 'array', 'itemType': 'number' },
            score: 'number',
            tag: 'string',
            type: 'string',
        };
    }
}
exports.RecognizePoiNameResponseBodyDataSignboardsTexts = RecognizePoiNameResponseBodyDataSignboardsTexts;
class RecognizePoiNameResponseBodyDataSignboards extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            texts: 'Texts',
        };
    }
    static types() {
        return {
            texts: { 'type': 'array', 'itemType': RecognizePoiNameResponseBodyDataSignboardsTexts },
        };
    }
}
exports.RecognizePoiNameResponseBodyDataSignboards = RecognizePoiNameResponseBodyDataSignboards;
class RecognizePoiNameResponseBodyDataSummary extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            brand: 'Brand',
            score: 'Score',
        };
    }
    static types() {
        return {
            brand: 'string',
            score: 'number',
        };
    }
}
exports.RecognizePoiNameResponseBodyDataSummary = RecognizePoiNameResponseBodyDataSummary;
class RecognizePoiNameResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            signboards: 'Signboards',
            summary: 'Summary',
        };
    }
    static types() {
        return {
            signboards: { 'type': 'array', 'itemType': RecognizePoiNameResponseBodyDataSignboards },
            summary: RecognizePoiNameResponseBodyDataSummary,
        };
    }
}
exports.RecognizePoiNameResponseBodyData = RecognizePoiNameResponseBodyData;
class RecognizeQrCodeRequestTasks extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeQrCodeRequestTasks = RecognizeQrCodeRequestTasks;
class RecognizeQrCodeAdvanceRequestTasks extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeQrCodeAdvanceRequestTasks = RecognizeQrCodeAdvanceRequestTasks;
class RecognizeQrCodeResponseBodyDataElementsResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            label: 'Label',
            qrCodesData: 'QrCodesData',
            rate: 'Rate',
            suggestion: 'Suggestion',
        };
    }
    static types() {
        return {
            label: 'string',
            qrCodesData: { 'type': 'array', 'itemType': 'string' },
            rate: 'number',
            suggestion: 'string',
        };
    }
}
exports.RecognizeQrCodeResponseBodyDataElementsResults = RecognizeQrCodeResponseBodyDataElementsResults;
class RecognizeQrCodeResponseBodyDataElements extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
            results: 'Results',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            imageURL: 'string',
            results: { 'type': 'array', 'itemType': RecognizeQrCodeResponseBodyDataElementsResults },
            taskId: 'string',
        };
    }
}
exports.RecognizeQrCodeResponseBodyDataElements = RecognizeQrCodeResponseBodyDataElements;
class RecognizeQrCodeResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            elements: 'Elements',
        };
    }
    static types() {
        return {
            elements: { 'type': 'array', 'itemType': RecognizeQrCodeResponseBodyDataElements },
        };
    }
}
exports.RecognizeQrCodeResponseBodyData = RecognizeQrCodeResponseBodyData;
class RecognizeQuotaInvoiceResponseBodyDataContent extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invoiceAmount: 'InvoiceAmount',
            invoiceCode: 'InvoiceCode',
            invoiceDetails: 'InvoiceDetails',
            invoiceNo: 'InvoiceNo',
            sumAmount: 'SumAmount',
        };
    }
    static types() {
        return {
            invoiceAmount: 'string',
            invoiceCode: 'string',
            invoiceDetails: 'string',
            invoiceNo: 'string',
            sumAmount: 'string',
        };
    }
}
exports.RecognizeQuotaInvoiceResponseBodyDataContent = RecognizeQuotaInvoiceResponseBodyDataContent;
class RecognizeQuotaInvoiceResponseBodyDataKeyValueInfosValuePositions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizeQuotaInvoiceResponseBodyDataKeyValueInfosValuePositions = RecognizeQuotaInvoiceResponseBodyDataKeyValueInfosValuePositions;
class RecognizeQuotaInvoiceResponseBodyDataKeyValueInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
            valuePositions: 'ValuePositions',
            valueScore: 'ValueScore',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
            valuePositions: { 'type': 'array', 'itemType': RecognizeQuotaInvoiceResponseBodyDataKeyValueInfosValuePositions },
            valueScore: 'number',
        };
    }
}
exports.RecognizeQuotaInvoiceResponseBodyDataKeyValueInfos = RecognizeQuotaInvoiceResponseBodyDataKeyValueInfos;
class RecognizeQuotaInvoiceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            angle: 'Angle',
            content: 'Content',
            height: 'Height',
            keyValueInfos: 'KeyValueInfos',
            orgHeight: 'OrgHeight',
            orgWidth: 'OrgWidth',
            width: 'Width',
        };
    }
    static types() {
        return {
            angle: 'number',
            content: RecognizeQuotaInvoiceResponseBodyDataContent,
            height: 'number',
            keyValueInfos: { 'type': 'array', 'itemType': RecognizeQuotaInvoiceResponseBodyDataKeyValueInfos },
            orgHeight: 'number',
            orgWidth: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeQuotaInvoiceResponseBodyData = RecognizeQuotaInvoiceResponseBodyData;
class RecognizeStampResponseBodyDataResultsGeneralText extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            confidence: 'Confidence',
            content: 'Content',
        };
    }
    static types() {
        return {
            confidence: 'number',
            content: 'string',
        };
    }
}
exports.RecognizeStampResponseBodyDataResultsGeneralText = RecognizeStampResponseBodyDataResultsGeneralText;
class RecognizeStampResponseBodyDataResultsRoi extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeStampResponseBodyDataResultsRoi = RecognizeStampResponseBodyDataResultsRoi;
class RecognizeStampResponseBodyDataResultsText extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            confidence: 'Confidence',
            content: 'Content',
        };
    }
    static types() {
        return {
            confidence: 'number',
            content: 'string',
        };
    }
}
exports.RecognizeStampResponseBodyDataResultsText = RecognizeStampResponseBodyDataResultsText;
class RecognizeStampResponseBodyDataResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            generalText: 'GeneralText',
            roi: 'Roi',
            text: 'Text',
        };
    }
    static types() {
        return {
            generalText: { 'type': 'array', 'itemType': RecognizeStampResponseBodyDataResultsGeneralText },
            roi: RecognizeStampResponseBodyDataResultsRoi,
            text: RecognizeStampResponseBodyDataResultsText,
        };
    }
}
exports.RecognizeStampResponseBodyDataResults = RecognizeStampResponseBodyDataResults;
class RecognizeStampResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            results: 'Results',
        };
    }
    static types() {
        return {
            results: { 'type': 'array', 'itemType': RecognizeStampResponseBodyDataResults },
        };
    }
}
exports.RecognizeStampResponseBodyData = RecognizeStampResponseBodyData;
class RecognizeTableResponseBodyDataTablesTableRowsTableColumns extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endColumn: 'EndColumn',
            endRow: 'EndRow',
            height: 'Height',
            startColumn: 'StartColumn',
            startRow: 'StartRow',
            texts: 'Texts',
            width: 'Width',
        };
    }
    static types() {
        return {
            endColumn: 'number',
            endRow: 'number',
            height: 'number',
            startColumn: 'number',
            startRow: 'number',
            texts: { 'type': 'array', 'itemType': 'string' },
            width: 'number',
        };
    }
}
exports.RecognizeTableResponseBodyDataTablesTableRowsTableColumns = RecognizeTableResponseBodyDataTablesTableRowsTableColumns;
class RecognizeTableResponseBodyDataTablesTableRows extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tableColumns: 'TableColumns',
        };
    }
    static types() {
        return {
            tableColumns: { 'type': 'array', 'itemType': RecognizeTableResponseBodyDataTablesTableRowsTableColumns },
        };
    }
}
exports.RecognizeTableResponseBodyDataTablesTableRows = RecognizeTableResponseBodyDataTablesTableRows;
class RecognizeTableResponseBodyDataTables extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            head: 'Head',
            tableRows: 'TableRows',
            tail: 'Tail',
        };
    }
    static types() {
        return {
            head: { 'type': 'array', 'itemType': 'string' },
            tableRows: { 'type': 'array', 'itemType': RecognizeTableResponseBodyDataTablesTableRows },
            tail: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.RecognizeTableResponseBodyDataTables = RecognizeTableResponseBodyDataTables;
class RecognizeTableResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileContent: 'FileContent',
            tables: 'Tables',
        };
    }
    static types() {
        return {
            fileContent: 'string',
            tables: { 'type': 'array', 'itemType': RecognizeTableResponseBodyDataTables },
        };
    }
}
exports.RecognizeTableResponseBodyData = RecognizeTableResponseBodyData;
class RecognizeTakeoutOrderResponseBodyDataElements extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            boxes: 'Boxes',
            name: 'Name',
            score: 'Score',
            value: 'Value',
        };
    }
    static types() {
        return {
            boxes: { 'type': 'array', 'itemType': 'number' },
            name: 'string',
            score: 'number',
            value: 'string',
        };
    }
}
exports.RecognizeTakeoutOrderResponseBodyDataElements = RecognizeTakeoutOrderResponseBodyDataElements;
class RecognizeTakeoutOrderResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            elements: 'Elements',
        };
    }
    static types() {
        return {
            elements: { 'type': 'array', 'itemType': RecognizeTakeoutOrderResponseBodyDataElements },
        };
    }
}
exports.RecognizeTakeoutOrderResponseBodyData = RecognizeTakeoutOrderResponseBodyData;
class RecognizeTaxiInvoiceResponseBodyDataInvoicesInvoiceRoi extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            h: 'H',
            w: 'W',
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            h: 'number',
            w: 'number',
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizeTaxiInvoiceResponseBodyDataInvoicesInvoiceRoi = RecognizeTaxiInvoiceResponseBodyDataInvoicesInvoiceRoi;
class RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoiCenter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoiCenter = RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoiCenter;
class RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoiSize extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            h: 'H',
            w: 'W',
        };
    }
    static types() {
        return {
            h: 'number',
            w: 'number',
        };
    }
}
exports.RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoiSize = RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoiSize;
class RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoi extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            angle: 'Angle',
            center: 'Center',
            size: 'Size',
        };
    }
    static types() {
        return {
            angle: 'number',
            center: RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoiCenter,
            size: RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoiSize,
        };
    }
}
exports.RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoi = RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoi;
class RecognizeTaxiInvoiceResponseBodyDataInvoicesItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            itemRoi: 'ItemRoi',
            text: 'Text',
        };
    }
    static types() {
        return {
            itemRoi: RecognizeTaxiInvoiceResponseBodyDataInvoicesItemsItemRoi,
            text: 'string',
        };
    }
}
exports.RecognizeTaxiInvoiceResponseBodyDataInvoicesItems = RecognizeTaxiInvoiceResponseBodyDataInvoicesItems;
class RecognizeTaxiInvoiceResponseBodyDataInvoices extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invoiceRoi: 'InvoiceRoi',
            items: 'Items',
            rotateType: 'RotateType',
        };
    }
    static types() {
        return {
            invoiceRoi: RecognizeTaxiInvoiceResponseBodyDataInvoicesInvoiceRoi,
            items: { 'type': 'array', 'itemType': RecognizeTaxiInvoiceResponseBodyDataInvoicesItems },
            rotateType: 'number',
        };
    }
}
exports.RecognizeTaxiInvoiceResponseBodyDataInvoices = RecognizeTaxiInvoiceResponseBodyDataInvoices;
class RecognizeTaxiInvoiceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invoices: 'Invoices',
        };
    }
    static types() {
        return {
            invoices: { 'type': 'array', 'itemType': RecognizeTaxiInvoiceResponseBodyDataInvoices },
        };
    }
}
exports.RecognizeTaxiInvoiceResponseBodyData = RecognizeTaxiInvoiceResponseBodyData;
class RecognizeTicketInvoiceResponseBodyDataResultsContent extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            antiFakeCode: 'AntiFakeCode',
            invoiceCode: 'InvoiceCode',
            invoiceDate: 'InvoiceDate',
            invoiceNumber: 'InvoiceNumber',
            payeeName: 'PayeeName',
            payeeRegisterNo: 'PayeeRegisterNo',
            payerName: 'PayerName',
            payerRegisterNo: 'PayerRegisterNo',
            sumAmount: 'SumAmount',
        };
    }
    static types() {
        return {
            antiFakeCode: 'string',
            invoiceCode: 'string',
            invoiceDate: 'string',
            invoiceNumber: 'string',
            payeeName: 'string',
            payeeRegisterNo: 'string',
            payerName: 'string',
            payerRegisterNo: 'string',
            sumAmount: 'string',
        };
    }
}
exports.RecognizeTicketInvoiceResponseBodyDataResultsContent = RecognizeTicketInvoiceResponseBodyDataResultsContent;
class RecognizeTicketInvoiceResponseBodyDataResultsKeyValueInfosValuePositions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizeTicketInvoiceResponseBodyDataResultsKeyValueInfosValuePositions = RecognizeTicketInvoiceResponseBodyDataResultsKeyValueInfosValuePositions;
class RecognizeTicketInvoiceResponseBodyDataResultsKeyValueInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
            valuePositions: 'ValuePositions',
            valueScore: 'ValueScore',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
            valuePositions: { 'type': 'array', 'itemType': RecognizeTicketInvoiceResponseBodyDataResultsKeyValueInfosValuePositions },
            valueScore: 'number',
        };
    }
}
exports.RecognizeTicketInvoiceResponseBodyDataResultsKeyValueInfos = RecognizeTicketInvoiceResponseBodyDataResultsKeyValueInfos;
class RecognizeTicketInvoiceResponseBodyDataResultsSliceRectangle extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizeTicketInvoiceResponseBodyDataResultsSliceRectangle = RecognizeTicketInvoiceResponseBodyDataResultsSliceRectangle;
class RecognizeTicketInvoiceResponseBodyDataResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'Content',
            index: 'Index',
            keyValueInfos: 'KeyValueInfos',
            sliceRectangle: 'SliceRectangle',
            type: 'Type',
        };
    }
    static types() {
        return {
            content: RecognizeTicketInvoiceResponseBodyDataResultsContent,
            index: 'number',
            keyValueInfos: { 'type': 'array', 'itemType': RecognizeTicketInvoiceResponseBodyDataResultsKeyValueInfos },
            sliceRectangle: { 'type': 'array', 'itemType': RecognizeTicketInvoiceResponseBodyDataResultsSliceRectangle },
            type: 'string',
        };
    }
}
exports.RecognizeTicketInvoiceResponseBodyDataResults = RecognizeTicketInvoiceResponseBodyDataResults;
class RecognizeTicketInvoiceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            count: 'Count',
            height: 'Height',
            orgHeight: 'OrgHeight',
            orgWidth: 'OrgWidth',
            results: 'Results',
            width: 'Width',
        };
    }
    static types() {
        return {
            count: 'number',
            height: 'number',
            orgHeight: 'number',
            orgWidth: 'number',
            results: { 'type': 'array', 'itemType': RecognizeTicketInvoiceResponseBodyDataResults },
            width: 'number',
        };
    }
}
exports.RecognizeTicketInvoiceResponseBodyData = RecognizeTicketInvoiceResponseBodyData;
class RecognizeTrainTicketResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'Date',
            departureStation: 'DepartureStation',
            destination: 'Destination',
            level: 'Level',
            name: 'Name',
            number: 'Number',
            price: 'Price',
            seat: 'Seat',
        };
    }
    static types() {
        return {
            date: 'string',
            departureStation: 'string',
            destination: 'string',
            level: 'string',
            name: 'string',
            number: 'string',
            price: 'number',
            seat: 'string',
        };
    }
}
exports.RecognizeTrainTicketResponseBodyData = RecognizeTrainTicketResponseBodyData;
class RecognizeVATInvoiceResponseBodyDataBox extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkers: 'Checkers',
            clerks: 'Clerks',
            invoiceAmounts: 'InvoiceAmounts',
            invoiceCodes: 'InvoiceCodes',
            invoiceDates: 'InvoiceDates',
            invoiceFakeCodes: 'InvoiceFakeCodes',
            invoiceNoes: 'InvoiceNoes',
            itemNames: 'ItemNames',
            payeeAddresses: 'PayeeAddresses',
            payeeBankNames: 'PayeeBankNames',
            payeeNames: 'PayeeNames',
            payeeRegisterNoes: 'PayeeRegisterNoes',
            payees: 'Payees',
            payerAddresses: 'PayerAddresses',
            payerBankNames: 'PayerBankNames',
            payerNames: 'PayerNames',
            payerRegisterNoes: 'PayerRegisterNoes',
            sumAmounts: 'SumAmounts',
            taxAmounts: 'TaxAmounts',
            withoutTaxAmounts: 'WithoutTaxAmounts',
        };
    }
    static types() {
        return {
            checkers: { 'type': 'array', 'itemType': 'number' },
            clerks: { 'type': 'array', 'itemType': 'number' },
            invoiceAmounts: { 'type': 'array', 'itemType': 'number' },
            invoiceCodes: { 'type': 'array', 'itemType': 'number' },
            invoiceDates: { 'type': 'array', 'itemType': 'number' },
            invoiceFakeCodes: { 'type': 'array', 'itemType': 'number' },
            invoiceNoes: { 'type': 'array', 'itemType': 'number' },
            itemNames: { 'type': 'array', 'itemType': 'number' },
            payeeAddresses: { 'type': 'array', 'itemType': 'number' },
            payeeBankNames: { 'type': 'array', 'itemType': 'number' },
            payeeNames: { 'type': 'array', 'itemType': 'number' },
            payeeRegisterNoes: { 'type': 'array', 'itemType': 'number' },
            payees: { 'type': 'array', 'itemType': 'number' },
            payerAddresses: { 'type': 'array', 'itemType': 'number' },
            payerBankNames: { 'type': 'array', 'itemType': 'number' },
            payerNames: { 'type': 'array', 'itemType': 'number' },
            payerRegisterNoes: { 'type': 'array', 'itemType': 'number' },
            sumAmounts: { 'type': 'array', 'itemType': 'number' },
            taxAmounts: { 'type': 'array', 'itemType': 'number' },
            withoutTaxAmounts: { 'type': 'array', 'itemType': 'number' },
        };
    }
}
exports.RecognizeVATInvoiceResponseBodyDataBox = RecognizeVATInvoiceResponseBodyDataBox;
class RecognizeVATInvoiceResponseBodyDataContent extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            antiFakeCode: 'AntiFakeCode',
            checker: 'Checker',
            clerk: 'Clerk',
            invoiceAmount: 'InvoiceAmount',
            invoiceCode: 'InvoiceCode',
            invoiceDate: 'InvoiceDate',
            invoiceNo: 'InvoiceNo',
            itemName: 'ItemName',
            payee: 'Payee',
            payeeAddress: 'PayeeAddress',
            payeeBankName: 'PayeeBankName',
            payeeName: 'PayeeName',
            payeeRegisterNo: 'PayeeRegisterNo',
            payerAddress: 'PayerAddress',
            payerBankName: 'PayerBankName',
            payerName: 'PayerName',
            payerRegisterNo: 'PayerRegisterNo',
            sumAmount: 'SumAmount',
            taxAmount: 'TaxAmount',
            withoutTaxAmount: 'WithoutTaxAmount',
        };
    }
    static types() {
        return {
            antiFakeCode: 'string',
            checker: 'string',
            clerk: 'string',
            invoiceAmount: 'string',
            invoiceCode: 'string',
            invoiceDate: 'string',
            invoiceNo: 'string',
            itemName: { 'type': 'array', 'itemType': 'string' },
            payee: 'string',
            payeeAddress: 'string',
            payeeBankName: 'string',
            payeeName: 'string',
            payeeRegisterNo: 'string',
            payerAddress: 'string',
            payerBankName: 'string',
            payerName: 'string',
            payerRegisterNo: 'string',
            sumAmount: 'string',
            taxAmount: 'string',
            withoutTaxAmount: 'string',
        };
    }
}
exports.RecognizeVATInvoiceResponseBodyDataContent = RecognizeVATInvoiceResponseBodyDataContent;
class RecognizeVATInvoiceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            box: 'Box',
            content: 'Content',
        };
    }
    static types() {
        return {
            box: RecognizeVATInvoiceResponseBodyDataBox,
            content: RecognizeVATInvoiceResponseBodyDataContent,
        };
    }
}
exports.RecognizeVATInvoiceResponseBodyData = RecognizeVATInvoiceResponseBodyData;
class RecognizeVINCodeResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            vinCode: 'VinCode',
        };
    }
    static types() {
        return {
            vinCode: 'string',
        };
    }
}
exports.RecognizeVINCodeResponseBodyData = RecognizeVINCodeResponseBodyData;
class RecognizeVerificationcodeResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'Content',
        };
    }
    static types() {
        return {
            content: 'string',
        };
    }
}
exports.RecognizeVerificationcodeResponseBodyData = RecognizeVerificationcodeResponseBodyData;
class RecognizeVideoCharacterResponseBodyDataFramesElementsTextRectangles extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            angle: 'Angle',
            height: 'Height',
            left: 'Left',
            top: 'Top',
            width: 'Width',
        };
    }
    static types() {
        return {
            angle: 'number',
            height: 'number',
            left: 'number',
            top: 'number',
            width: 'number',
        };
    }
}
exports.RecognizeVideoCharacterResponseBodyDataFramesElementsTextRectangles = RecognizeVideoCharacterResponseBodyDataFramesElementsTextRectangles;
class RecognizeVideoCharacterResponseBodyDataFramesElements extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            score: 'Score',
            text: 'Text',
            textRectangles: 'TextRectangles',
        };
    }
    static types() {
        return {
            score: 'number',
            text: 'string',
            textRectangles: { 'type': 'array', 'itemType': RecognizeVideoCharacterResponseBodyDataFramesElementsTextRectangles },
        };
    }
}
exports.RecognizeVideoCharacterResponseBodyDataFramesElements = RecognizeVideoCharacterResponseBodyDataFramesElements;
class RecognizeVideoCharacterResponseBodyDataFrames extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            elements: 'Elements',
            timestamp: 'Timestamp',
        };
    }
    static types() {
        return {
            elements: { 'type': 'array', 'itemType': RecognizeVideoCharacterResponseBodyDataFramesElements },
            timestamp: 'number',
        };
    }
}
exports.RecognizeVideoCharacterResponseBodyDataFrames = RecognizeVideoCharacterResponseBodyDataFrames;
class RecognizeVideoCharacterResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            frames: 'Frames',
            height: 'Height',
            inputFile: 'InputFile',
            width: 'Width',
        };
    }
    static types() {
        return {
            frames: { 'type': 'array', 'itemType': RecognizeVideoCharacterResponseBodyDataFrames },
            height: 'number',
            inputFile: 'string',
            width: 'number',
        };
    }
}
exports.RecognizeVideoCharacterResponseBodyData = RecognizeVideoCharacterResponseBodyData;
class TrimDocumentResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'Content',
        };
    }
    static types() {
        return {
            content: 'string',
        };
    }
}
exports.TrimDocumentResponseBodyData = TrimDocumentResponseBodyData;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "regional";
        this.checkConfig(config);
        this._endpoint = this.getEndpoint("ocr", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
    }
    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {
        if (!tea_util_1.default.empty(endpoint)) {
            return endpoint;
        }
        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {
            return endpointMap[regionId];
        }
        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);
    }
    async detectCardScreenshotWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DetectCardScreenshot",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DetectCardScreenshotResponse({}));
    }
    async detectCardScreenshot(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.detectCardScreenshotWithOptions(request, runtime);
    }
    async detectCardScreenshotAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let detectCardScreenshotReq = new DetectCardScreenshotRequest({});
        openapi_util_1.default.convert(request, detectCardScreenshotReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            detectCardScreenshotReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let detectCardScreenshotResp = await this.detectCardScreenshotWithOptions(detectCardScreenshotReq, runtime);
        return detectCardScreenshotResp;
    }
    async getAsyncJobResultWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.jobId)) {
            body["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetAsyncJobResult",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetAsyncJobResultResponse({}));
    }
    async getAsyncJobResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getAsyncJobResultWithOptions(request, runtime);
    }
    async recognizeAccountPageWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeAccountPage",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeAccountPageResponse({}));
    }
    async recognizeAccountPage(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeAccountPageWithOptions(request, runtime);
    }
    async recognizeAccountPageAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeAccountPageReq = new RecognizeAccountPageRequest({});
        openapi_util_1.default.convert(request, recognizeAccountPageReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeAccountPageReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeAccountPageResp = await this.recognizeAccountPageWithOptions(recognizeAccountPageReq, runtime);
        return recognizeAccountPageResp;
    }
    async recognizeBankCardWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeBankCard",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeBankCardResponse({}));
    }
    async recognizeBankCard(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeBankCardWithOptions(request, runtime);
    }
    async recognizeBankCardAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeBankCardReq = new RecognizeBankCardRequest({});
        openapi_util_1.default.convert(request, recognizeBankCardReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeBankCardReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeBankCardResp = await this.recognizeBankCardWithOptions(recognizeBankCardReq, runtime);
        return recognizeBankCardResp;
    }
    async recognizeBusinessCardWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeBusinessCard",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeBusinessCardResponse({}));
    }
    async recognizeBusinessCard(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeBusinessCardWithOptions(request, runtime);
    }
    async recognizeBusinessCardAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeBusinessCardReq = new RecognizeBusinessCardRequest({});
        openapi_util_1.default.convert(request, recognizeBusinessCardReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeBusinessCardReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeBusinessCardResp = await this.recognizeBusinessCardWithOptions(recognizeBusinessCardReq, runtime);
        return recognizeBusinessCardResp;
    }
    async recognizeBusinessLicenseWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeBusinessLicense",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeBusinessLicenseResponse({}));
    }
    async recognizeBusinessLicense(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeBusinessLicenseWithOptions(request, runtime);
    }
    async recognizeBusinessLicenseAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeBusinessLicenseReq = new RecognizeBusinessLicenseRequest({});
        openapi_util_1.default.convert(request, recognizeBusinessLicenseReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeBusinessLicenseReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeBusinessLicenseResp = await this.recognizeBusinessLicenseWithOptions(recognizeBusinessLicenseReq, runtime);
        return recognizeBusinessLicenseResp;
    }
    async recognizeCharacterWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        if (!tea_util_1.default.isUnset(request.minHeight)) {
            body["MinHeight"] = request.minHeight;
        }
        if (!tea_util_1.default.isUnset(request.outputProbability)) {
            body["OutputProbability"] = request.outputProbability;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeCharacter",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeCharacterResponse({}));
    }
    async recognizeCharacter(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeCharacterWithOptions(request, runtime);
    }
    async recognizeCharacterAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeCharacterReq = new RecognizeCharacterRequest({});
        openapi_util_1.default.convert(request, recognizeCharacterReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeCharacterReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeCharacterResp = await this.recognizeCharacterWithOptions(recognizeCharacterReq, runtime);
        return recognizeCharacterResp;
    }
    async recognizeChinapassportWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeChinapassport",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeChinapassportResponse({}));
    }
    async recognizeChinapassport(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeChinapassportWithOptions(request, runtime);
    }
    async recognizeChinapassportAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeChinapassportReq = new RecognizeChinapassportRequest({});
        openapi_util_1.default.convert(request, recognizeChinapassportReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeChinapassportReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeChinapassportResp = await this.recognizeChinapassportWithOptions(recognizeChinapassportReq, runtime);
        return recognizeChinapassportResp;
    }
    async recognizeDriverLicenseWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        if (!tea_util_1.default.isUnset(request.side)) {
            body["Side"] = request.side;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeDriverLicense",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeDriverLicenseResponse({}));
    }
    async recognizeDriverLicense(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeDriverLicenseWithOptions(request, runtime);
    }
    async recognizeDriverLicenseAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeDriverLicenseReq = new RecognizeDriverLicenseRequest({});
        openapi_util_1.default.convert(request, recognizeDriverLicenseReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeDriverLicenseReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeDriverLicenseResp = await this.recognizeDriverLicenseWithOptions(recognizeDriverLicenseReq, runtime);
        return recognizeDriverLicenseResp;
    }
    async recognizeDrivingLicenseWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        if (!tea_util_1.default.isUnset(request.side)) {
            body["Side"] = request.side;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeDrivingLicense",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeDrivingLicenseResponse({}));
    }
    async recognizeDrivingLicense(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeDrivingLicenseWithOptions(request, runtime);
    }
    async recognizeDrivingLicenseAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeDrivingLicenseReq = new RecognizeDrivingLicenseRequest({});
        openapi_util_1.default.convert(request, recognizeDrivingLicenseReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeDrivingLicenseReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeDrivingLicenseResp = await this.recognizeDrivingLicenseWithOptions(recognizeDrivingLicenseReq, runtime);
        return recognizeDrivingLicenseResp;
    }
    async recognizeIdentityCardWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        if (!tea_util_1.default.isUnset(request.side)) {
            body["Side"] = request.side;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeIdentityCard",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeIdentityCardResponse({}));
    }
    async recognizeIdentityCard(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeIdentityCardWithOptions(request, runtime);
    }
    async recognizeIdentityCardAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeIdentityCardReq = new RecognizeIdentityCardRequest({});
        openapi_util_1.default.convert(request, recognizeIdentityCardReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeIdentityCardReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeIdentityCardResp = await this.recognizeIdentityCardWithOptions(recognizeIdentityCardReq, runtime);
        return recognizeIdentityCardResp;
    }
    async recognizeLicensePlateWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeLicensePlate",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeLicensePlateResponse({}));
    }
    async recognizeLicensePlate(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeLicensePlateWithOptions(request, runtime);
    }
    async recognizeLicensePlateAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeLicensePlateReq = new RecognizeLicensePlateRequest({});
        openapi_util_1.default.convert(request, recognizeLicensePlateReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeLicensePlateReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeLicensePlateResp = await this.recognizeLicensePlateWithOptions(recognizeLicensePlateReq, runtime);
        return recognizeLicensePlateResp;
    }
    async recognizePassportMRZWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizePassportMRZ",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizePassportMRZResponse({}));
    }
    async recognizePassportMRZ(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizePassportMRZWithOptions(request, runtime);
    }
    async recognizePassportMRZAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizePassportMRZReq = new RecognizePassportMRZRequest({});
        openapi_util_1.default.convert(request, recognizePassportMRZReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizePassportMRZReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizePassportMRZResp = await this.recognizePassportMRZWithOptions(recognizePassportMRZReq, runtime);
        return recognizePassportMRZResp;
    }
    async recognizePdfWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.fileURL)) {
            body["FileURL"] = request.fileURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizePdf",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizePdfResponse({}));
    }
    async recognizePdf(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizePdfWithOptions(request, runtime);
    }
    async recognizePdfAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizePdfReq = new RecognizePdfRequest({});
        openapi_util_1.default.convert(request, recognizePdfReq);
        if (!tea_util_1.default.isUnset(request.fileURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.fileURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizePdfReq.fileURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizePdfResp = await this.recognizePdfWithOptions(recognizePdfReq, runtime);
        return recognizePdfResp;
    }
    async recognizePoiNameWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizePoiName",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizePoiNameResponse({}));
    }
    async recognizePoiName(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizePoiNameWithOptions(request, runtime);
    }
    async recognizePoiNameAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizePoiNameReq = new RecognizePoiNameRequest({});
        openapi_util_1.default.convert(request, recognizePoiNameReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizePoiNameReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizePoiNameResp = await this.recognizePoiNameWithOptions(recognizePoiNameReq, runtime);
        return recognizePoiNameResp;
    }
    async recognizeQrCodeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.tasks)) {
            body["Tasks"] = request.tasks;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeQrCode",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeQrCodeResponse({}));
    }
    async recognizeQrCode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeQrCodeWithOptions(request, runtime);
    }
    async recognizeQrCodeAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeQrCodeReq = new RecognizeQrCodeRequest({});
        openapi_util_1.default.convert(request, recognizeQrCodeReq);
        if (!tea_util_1.default.isUnset(request.tasks)) {
            let i0 = 0;
            for (let item0 of request.tasks) {
                if (!tea_util_1.default.isUnset(item0.imageURLObject)) {
                    authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
                    ossConfig.accessKeyId = authResponse.body.accessKeyId;
                    ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
                    ossClient = new oss_client_1.default(ossConfig);
                    fileObj = new $FileForm.FileField({
                        filename: authResponse.body.objectKey,
                        content: item0.imageURLObject,
                        contentType: "",
                    });
                    ossHeader = new $OSS.PostObjectRequestHeader({
                        accessKeyId: authResponse.body.accessKeyId,
                        policy: authResponse.body.encodedPolicy,
                        signature: authResponse.body.signature,
                        key: authResponse.body.objectKey,
                        file: fileObj,
                        successActionStatus: "201",
                    });
                    uploadRequest = new $OSS.PostObjectRequest({
                        bucketName: authResponse.body.bucket,
                        header: ossHeader,
                    });
                    await ossClient.postObject(uploadRequest, ossRuntime);
                    let tmp = recognizeQrCodeReq.tasks[i0];
                    tmp.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
                    i0 = number_1.default.ltoi(number_1.default.add(number_1.default.itol(i0), number_1.default.itol(1)));
                }
            }
        }
        let recognizeQrCodeResp = await this.recognizeQrCodeWithOptions(recognizeQrCodeReq, runtime);
        return recognizeQrCodeResp;
    }
    async recognizeQuotaInvoiceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeQuotaInvoice",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeQuotaInvoiceResponse({}));
    }
    async recognizeQuotaInvoice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeQuotaInvoiceWithOptions(request, runtime);
    }
    async recognizeQuotaInvoiceAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeQuotaInvoiceReq = new RecognizeQuotaInvoiceRequest({});
        openapi_util_1.default.convert(request, recognizeQuotaInvoiceReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeQuotaInvoiceReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeQuotaInvoiceResp = await this.recognizeQuotaInvoiceWithOptions(recognizeQuotaInvoiceReq, runtime);
        return recognizeQuotaInvoiceResp;
    }
    async recognizeStampWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeStamp",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeStampResponse({}));
    }
    async recognizeStamp(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeStampWithOptions(request, runtime);
    }
    async recognizeStampAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeStampReq = new RecognizeStampRequest({});
        openapi_util_1.default.convert(request, recognizeStampReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeStampReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeStampResp = await this.recognizeStampWithOptions(recognizeStampReq, runtime);
        return recognizeStampResp;
    }
    async recognizeTableWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.assureDirection)) {
            body["AssureDirection"] = request.assureDirection;
        }
        if (!tea_util_1.default.isUnset(request.hasLine)) {
            body["HasLine"] = request.hasLine;
        }
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        if (!tea_util_1.default.isUnset(request.outputFormat)) {
            body["OutputFormat"] = request.outputFormat;
        }
        if (!tea_util_1.default.isUnset(request.skipDetection)) {
            body["SkipDetection"] = request.skipDetection;
        }
        if (!tea_util_1.default.isUnset(request.useFinanceModel)) {
            body["UseFinanceModel"] = request.useFinanceModel;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeTable",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeTableResponse({}));
    }
    async recognizeTable(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeTableWithOptions(request, runtime);
    }
    async recognizeTableAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeTableReq = new RecognizeTableRequest({});
        openapi_util_1.default.convert(request, recognizeTableReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeTableReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeTableResp = await this.recognizeTableWithOptions(recognizeTableReq, runtime);
        return recognizeTableResp;
    }
    async recognizeTakeoutOrderWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeTakeoutOrder",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeTakeoutOrderResponse({}));
    }
    async recognizeTakeoutOrder(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeTakeoutOrderWithOptions(request, runtime);
    }
    async recognizeTakeoutOrderAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeTakeoutOrderReq = new RecognizeTakeoutOrderRequest({});
        openapi_util_1.default.convert(request, recognizeTakeoutOrderReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeTakeoutOrderReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeTakeoutOrderResp = await this.recognizeTakeoutOrderWithOptions(recognizeTakeoutOrderReq, runtime);
        return recognizeTakeoutOrderResp;
    }
    async recognizeTaxiInvoiceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeTaxiInvoice",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeTaxiInvoiceResponse({}));
    }
    async recognizeTaxiInvoice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeTaxiInvoiceWithOptions(request, runtime);
    }
    async recognizeTaxiInvoiceAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeTaxiInvoiceReq = new RecognizeTaxiInvoiceRequest({});
        openapi_util_1.default.convert(request, recognizeTaxiInvoiceReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeTaxiInvoiceReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeTaxiInvoiceResp = await this.recognizeTaxiInvoiceWithOptions(recognizeTaxiInvoiceReq, runtime);
        return recognizeTaxiInvoiceResp;
    }
    async recognizeTicketInvoiceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeTicketInvoice",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeTicketInvoiceResponse({}));
    }
    async recognizeTicketInvoice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeTicketInvoiceWithOptions(request, runtime);
    }
    async recognizeTicketInvoiceAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeTicketInvoiceReq = new RecognizeTicketInvoiceRequest({});
        openapi_util_1.default.convert(request, recognizeTicketInvoiceReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeTicketInvoiceReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeTicketInvoiceResp = await this.recognizeTicketInvoiceWithOptions(recognizeTicketInvoiceReq, runtime);
        return recognizeTicketInvoiceResp;
    }
    async recognizeTrainTicketWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeTrainTicket",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeTrainTicketResponse({}));
    }
    async recognizeTrainTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeTrainTicketWithOptions(request, runtime);
    }
    async recognizeTrainTicketAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeTrainTicketReq = new RecognizeTrainTicketRequest({});
        openapi_util_1.default.convert(request, recognizeTrainTicketReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeTrainTicketReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeTrainTicketResp = await this.recognizeTrainTicketWithOptions(recognizeTrainTicketReq, runtime);
        return recognizeTrainTicketResp;
    }
    async recognizeVATInvoiceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.fileType)) {
            body["FileType"] = request.fileType;
        }
        if (!tea_util_1.default.isUnset(request.fileURL)) {
            body["FileURL"] = request.fileURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeVATInvoice",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeVATInvoiceResponse({}));
    }
    async recognizeVATInvoice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeVATInvoiceWithOptions(request, runtime);
    }
    async recognizeVATInvoiceAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeVATInvoiceReq = new RecognizeVATInvoiceRequest({});
        openapi_util_1.default.convert(request, recognizeVATInvoiceReq);
        if (!tea_util_1.default.isUnset(request.fileURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.fileURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeVATInvoiceReq.fileURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeVATInvoiceResp = await this.recognizeVATInvoiceWithOptions(recognizeVATInvoiceReq, runtime);
        return recognizeVATInvoiceResp;
    }
    async recognizeVINCodeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            query["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeVINCode",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeVINCodeResponse({}));
    }
    async recognizeVINCode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeVINCodeWithOptions(request, runtime);
    }
    async recognizeVINCodeAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeVINCodeReq = new RecognizeVINCodeRequest({});
        openapi_util_1.default.convert(request, recognizeVINCodeReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeVINCodeReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeVINCodeResp = await this.recognizeVINCodeWithOptions(recognizeVINCodeReq, runtime);
        return recognizeVINCodeResp;
    }
    async recognizeVerificationcodeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeVerificationcode",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeVerificationcodeResponse({}));
    }
    async recognizeVerificationcode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeVerificationcodeWithOptions(request, runtime);
    }
    async recognizeVerificationcodeAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeVerificationcodeReq = new RecognizeVerificationcodeRequest({});
        openapi_util_1.default.convert(request, recognizeVerificationcodeReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeVerificationcodeReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeVerificationcodeResp = await this.recognizeVerificationcodeWithOptions(recognizeVerificationcodeReq, runtime);
        return recognizeVerificationcodeResp;
    }
    async recognizeVideoCharacterWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.videoURL)) {
            body["VideoURL"] = request.videoURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeVideoCharacter",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeVideoCharacterResponse({}));
    }
    async recognizeVideoCharacter(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeVideoCharacterWithOptions(request, runtime);
    }
    async recognizeVideoCharacterAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeVideoCharacterReq = new RecognizeVideoCharacterRequest({});
        openapi_util_1.default.convert(request, recognizeVideoCharacterReq);
        if (!tea_util_1.default.isUnset(request.videoURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.videoURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeVideoCharacterReq.videoURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeVideoCharacterResp = await this.recognizeVideoCharacterWithOptions(recognizeVideoCharacterReq, runtime);
        return recognizeVideoCharacterResp;
    }
    async trimDocumentWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.fileType)) {
            body["FileType"] = request.fileType;
        }
        if (!tea_util_1.default.isUnset(request.fileURL)) {
            body["FileURL"] = request.fileURL;
        }
        if (!tea_util_1.default.isUnset(request.outputType)) {
            body["OutputType"] = request.outputType;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TrimDocument",
            version: "2019-12-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TrimDocumentResponse({}));
    }
    async trimDocument(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.trimDocumentWithOptions(request, runtime);
    }
    async trimDocumentAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "ocr",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let trimDocumentReq = new TrimDocumentRequest({});
        openapi_util_1.default.convert(request, trimDocumentReq);
        if (!tea_util_1.default.isUnset(request.fileURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.fileURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            trimDocumentReq.fileURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let trimDocumentResp = await this.trimDocumentWithOptions(trimDocumentReq, runtime);
        return trimDocumentResp;
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map